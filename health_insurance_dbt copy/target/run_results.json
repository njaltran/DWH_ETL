{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.11.2", "generated_at": "2026-01-05T14:37:57.425430Z", "invocation_id": "07c8fa2e-901f-4093-afef-e4efa1d0a867", "invocation_started_at": "2026-01-05T14:37:28.663886Z", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:45.021429Z", "completed_at": "2026-01-05T14:37:45.026839Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:45.027316Z", "completed_at": "2026-01-05T14:37:46.618269Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 1.6109528541564941, "adapter_response": {"_message": "CREATE VIEW (0 processed)", "code": "CREATE VIEW", "bytes_processed": 0, "bytes_billed": 0, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "5f17a1df-5ba0-43d6-a619-5bb0a27c8d01", "slot_ms": 0}, "message": "CREATE VIEW (0 processed)", "failures": null, "unique_id": "model.health_insurance_dbt.stg_person_dim_raw", "compiled": true, "compiled_code": "\n\n-- Light cleaning and selection of raw person dimension data\n-- No deduplication at this stage\n\nSELECT\n  TRIM(Person_id) AS person_id,\n  TRIM(birthdate) AS birthdate_raw,\n  TRIM(address) AS address_raw,\n  TRIM(gender) AS gender_raw,\n  TRIM(family_status) AS family_status_raw,\n  TRIM(insurance_status) AS insurance_status_raw,\n  TRIM(insurance_sign_up_date) AS insurance_sign_up_date_raw,\n  TRIM(occupational_category) AS occupational_category_raw,\n  TRIM(wealth_bracket) AS wealth_bracket_raw\nFROM `dw-health-insurance-bipm`.`health_insurance_raw`.`health_insurance_person_dim_raw`\nWHERE Person_id IS NOT NULL", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev_staging`.`stg_person_dim_raw`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:45.009846Z", "completed_at": "2026-01-05T14:37:45.038987Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:45.045830Z", "completed_at": "2026-01-05T14:37:46.619173Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 1.6121909618377686, "adapter_response": {"_message": "CREATE VIEW (0 processed)", "code": "CREATE VIEW", "bytes_processed": 0, "bytes_billed": 0, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "ab31fc78-c6d7-4109-9415-9adc11e4e8f6", "slot_ms": 0}, "message": "CREATE VIEW (0 processed)", "failures": null, "unique_id": "model.health_insurance_dbt.stg_insurance_facts_raw", "compiled": true, "compiled_code": "\n\n-- Light cleaning and safe type casting of raw insurance facts\n-- Preserve all records with parse error flags\n\nWITH source AS (\n  SELECT\n    TRIM(Person_id) AS person_id,\n    insurance_cost_year,\n    annual_doctor_visits,\n    annual_cost_to_insurance,\n    year\n  FROM `dw-health-insurance-bipm`.`health_insurance_raw`.`health_insurance_insurance_facts_raw`\n  WHERE Person_id IS NOT NULL\n)\n\nSELECT\n  person_id,\n  \n  -- Safe numeric conversions with error flags\n  SAFE_CAST(insurance_cost_year AS NUMERIC) AS insurance_cost_year,\n  CASE WHEN SAFE_CAST(insurance_cost_year AS NUMERIC) IS NULL \n       AND insurance_cost_year IS NOT NULL \n       THEN TRUE ELSE FALSE END AS insurance_cost_year_parse_error,\n  \n  SAFE_CAST(annual_doctor_visits AS INT64) AS annual_doctor_visits,\n  CASE WHEN SAFE_CAST(annual_doctor_visits AS INT64) IS NULL \n       AND annual_doctor_visits IS NOT NULL \n       THEN TRUE ELSE FALSE END AS annual_doctor_visits_parse_error,\n  \n  SAFE_CAST(annual_cost_to_insurance AS NUMERIC) AS annual_cost_to_insurance,\n  CASE WHEN SAFE_CAST(annual_cost_to_insurance AS NUMERIC) IS NULL \n       AND annual_cost_to_insurance IS NOT NULL \n       THEN TRUE ELSE FALSE END AS annual_cost_to_insurance_parse_error,\n  \n  SAFE_CAST(year AS INT64) AS year,\n  CASE WHEN SAFE_CAST(year AS INT64) IS NULL \n       AND year IS NOT NULL \n       THEN TRUE ELSE FALSE END AS year_parse_error\n\nFROM source", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev_staging`.`stg_insurance_facts_raw`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:46.630469Z", "completed_at": "2026-01-05T14:37:46.636506Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:46.636748Z", "completed_at": "2026-01-05T14:37:50.411147Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 3.7825169563293457, "adapter_response": {"_message": "CREATE TABLE (166.0 rows, 12.4 KiB processed)", "code": "CREATE TABLE", "rows_affected": 166, "bytes_processed": 12724, "bytes_billed": 10485760, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "3068facd-1f3a-45ee-93f9-9ecd1bed9251", "slot_ms": 26688}, "message": "CREATE TABLE (166.0 rows, 12.4 KiB processed)", "failures": null, "unique_id": "model.health_insurance_dbt.dim_person", "compiled": true, "compiled_code": "\n\n-- Conformed person dimension (SCD Type 1)\n-- Grain: One row per person_id\n-- Business key: person_id\n\nWITH  __dbt__cte__int_person_deduped as (\n\n\n-- Parse dates, standardize categories, extract address components\n-- Each raw row is cleaned but duplicates remain\n\nWITH source AS (\n  SELECT * FROM `dw-health-insurance-bipm`.`health_insurance_dev_staging`.`stg_person_dim_raw`\n),\n\n-- Date parsing logic for birthdate\nbirthdate_parsed AS (\n  SELECT\n    person_id,\n    birthdate_raw,\n    \n    -- Try multiple date formats\n    COALESCE(\n      -- ISO format: YYYY-MM-DD\n      SAFE.PARSE_DATE('%Y-%m-%d', birthdate_raw),\n      \n      -- Dot format: DD.MM.YYYY\n      SAFE.PARSE_DATE('%d.%m.%Y', birthdate_raw),\n      \n      -- Dash format: DD-MM-YYYY\n      SAFE.PARSE_DATE('%d-%m-%Y', birthdate_raw),\n      \n      -- Slash format with heuristic (birthdate defaults to MM/DD/...)\n      CASE\n        -- Check if it's a slash-delimited date\n        WHEN REGEXP_CONTAINS(birthdate_raw, r'^\\d{1,2}/\\d{1,2}/\\d{2,4}$') THEN\n          CASE\n            -- Extract parts\n            WHEN SAFE_CAST(SPLIT(birthdate_raw, '/')[OFFSET(1)] AS INT64) > 12 THEN\n              -- Second part > 12, must be MM/DD/...\n              CASE\n                WHEN LENGTH(SPLIT(birthdate_raw, '/')[OFFSET(2)]) = 4 THEN\n                  SAFE.PARSE_DATE('%m/%d/%Y', birthdate_raw)\n                ELSE\n                  -- 2-digit year\n                  CASE\n                    WHEN SAFE_CAST(SPLIT(birthdate_raw, '/')[OFFSET(2)] AS INT64) BETWEEN 0 AND 29 THEN\n                      SAFE.PARSE_DATE('%m/%d/%y', REPLACE(birthdate_raw, '/' || SPLIT(birthdate_raw, '/')[OFFSET(2)], '/20' || SPLIT(birthdate_raw, '/')[OFFSET(2)]))\n                    ELSE\n                      SAFE.PARSE_DATE('%m/%d/%y', REPLACE(birthdate_raw, '/' || SPLIT(birthdate_raw, '/')[OFFSET(2)], '/19' || SPLIT(birthdate_raw, '/')[OFFSET(2)]))\n                  END\n              END\n            \n            WHEN SAFE_CAST(SPLIT(birthdate_raw, '/')[OFFSET(0)] AS INT64) > 12 THEN\n              -- First part > 12, must be DD/MM/...\n              CASE\n                WHEN LENGTH(SPLIT(birthdate_raw, '/')[OFFSET(2)]) = 4 THEN\n                  SAFE.PARSE_DATE('%d/%m/%Y', birthdate_raw)\n                ELSE\n                  -- 2-digit year\n                  CASE\n                    WHEN SAFE_CAST(SPLIT(birthdate_raw, '/')[OFFSET(2)] AS INT64) BETWEEN 0 AND 29 THEN\n                      SAFE.PARSE_DATE('%d/%m/%y', REPLACE(birthdate_raw, '/' || SPLIT(birthdate_raw, '/')[OFFSET(2)], '/20' || SPLIT(birthdate_raw, '/')[OFFSET(2)]))\n                    ELSE\n                      SAFE.PARSE_DATE('%d/%m/%y', REPLACE(birthdate_raw, '/' || SPLIT(birthdate_raw, '/')[OFFSET(2)], '/19' || SPLIT(birthdate_raw, '/')[OFFSET(2)]))\n                  END\n              END\n            \n            ELSE\n              -- Ambiguous: default to MM/DD/... for birthdate\n              CASE\n                WHEN LENGTH(SPLIT(birthdate_raw, '/')[OFFSET(2)]) = 4 THEN\n                  SAFE.PARSE_DATE('%m/%d/%Y', birthdate_raw)\n                ELSE\n                  -- 2-digit year\n                  CASE\n                    WHEN SAFE_CAST(SPLIT(birthdate_raw, '/')[OFFSET(2)] AS INT64) BETWEEN 0 AND 29 THEN\n                      SAFE.PARSE_DATE('%m/%d/%y', REPLACE(birthdate_raw, '/' || SPLIT(birthdate_raw, '/')[OFFSET(2)], '/20' || SPLIT(birthdate_raw, '/')[OFFSET(2)]))\n                    ELSE\n                      SAFE.PARSE_DATE('%m/%d/%y', REPLACE(birthdate_raw, '/' || SPLIT(birthdate_raw, '/')[OFFSET(2)], '/19' || SPLIT(birthdate_raw, '/')[OFFSET(2)]))\n                  END\n              END\n          END\n      END\n    ) AS birthdate_parsed\n  FROM source\n),\n\n-- Date parsing logic for insurance_sign_up_date\nsignup_date_parsed AS (\n  SELECT\n    person_id,\n    insurance_sign_up_date_raw,\n    \n    COALESCE(\n      -- ISO format: YYYY-MM-DD\n      SAFE.PARSE_DATE('%Y-%m-%d', insurance_sign_up_date_raw),\n      \n      -- Dot format: DD.MM.YYYY\n      SAFE.PARSE_DATE('%d.%m.%Y', insurance_sign_up_date_raw),\n      \n      -- Dash format: DD-MM-YYYY\n      SAFE.PARSE_DATE('%d-%m-%Y', insurance_sign_up_date_raw),\n      \n      -- Slash format with heuristic (signup defaults to DD/MM/...)\n      CASE\n        WHEN REGEXP_CONTAINS(insurance_sign_up_date_raw, r'^\\d{1,2}/\\d{1,2}/\\d{2,4}$') THEN\n          CASE\n            WHEN SAFE_CAST(SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(1)] AS INT64) > 12 THEN\n              -- Second part > 12, must be MM/DD/...\n              CASE\n                WHEN LENGTH(SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)]) = 4 THEN\n                  SAFE.PARSE_DATE('%m/%d/%Y', insurance_sign_up_date_raw)\n                ELSE\n                  CASE\n                    WHEN SAFE_CAST(SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)] AS INT64) BETWEEN 0 AND 29 THEN\n                      SAFE.PARSE_DATE('%m/%d/%y', REPLACE(insurance_sign_up_date_raw, '/' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)], '/20' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)]))\n                    ELSE\n                      SAFE.PARSE_DATE('%m/%d/%y', REPLACE(insurance_sign_up_date_raw, '/' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)], '/19' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)]))\n                  END\n              END\n            \n            WHEN SAFE_CAST(SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(0)] AS INT64) > 12 THEN\n              -- First part > 12, must be DD/MM/...\n              CASE\n                WHEN LENGTH(SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)]) = 4 THEN\n                  SAFE.PARSE_DATE('%d/%m/%Y', insurance_sign_up_date_raw)\n                ELSE\n                  CASE\n                    WHEN SAFE_CAST(SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)] AS INT64) BETWEEN 0 AND 29 THEN\n                      SAFE.PARSE_DATE('%d/%m/%y', REPLACE(insurance_sign_up_date_raw, '/' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)], '/20' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)]))\n                    ELSE\n                      SAFE.PARSE_DATE('%d/%m/%y', REPLACE(insurance_sign_up_date_raw, '/' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)], '/19' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)]))\n                  END\n              END\n            \n            ELSE\n              -- Ambiguous: default to DD/MM/... for signup date\n              CASE\n                WHEN LENGTH(SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)]) = 4 THEN\n                  SAFE.PARSE_DATE('%d/%m/%Y', insurance_sign_up_date_raw)\n                ELSE\n                  CASE\n                    WHEN SAFE_CAST(SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)] AS INT64) BETWEEN 0 AND 29 THEN\n                      SAFE.PARSE_DATE('%d/%m/%y', REPLACE(insurance_sign_up_date_raw, '/' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)], '/20' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)]))\n                    ELSE\n                      SAFE.PARSE_DATE('%d/%m/%y', REPLACE(insurance_sign_up_date_raw, '/' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)], '/19' || SPLIT(insurance_sign_up_date_raw, '/')[OFFSET(2)]))\n                  END\n              END\n          END\n      END\n    ) AS insurance_sign_up_date_parsed\n  FROM source\n),\n\n-- Address parsing\naddress_parsed AS (\n  SELECT\n    person_id,\n    address_raw,\n    REGEXP_REPLACE(TRIM(address_raw), r'\\s+', ' ') AS address_clean,\n    REGEXP_EXTRACT(address_raw, r'\\b(\\d{5})\\b') AS postal_code,\n    INITCAP(TRIM(REGEXP_EXTRACT(address_raw, r'\\d{5}\\s+(.+)$'))) AS city,\n    TRIM(SPLIT(address_raw, ',')[SAFE_OFFSET(0)]) AS street_and_number\n  FROM source\n)\n\n-- Final cleaned output\nSELECT\n  s.person_id,\n  \n  -- Dates with parse error flags\n  bd.birthdate_parsed,\n  CASE WHEN bd.birthdate_parsed IS NULL AND s.birthdate_raw IS NOT NULL \n       THEN TRUE ELSE FALSE END AS birthdate_parse_error,\n  \n  sd.insurance_sign_up_date_parsed,\n  CASE WHEN sd.insurance_sign_up_date_parsed IS NULL AND s.insurance_sign_up_date_raw IS NOT NULL \n       THEN TRUE ELSE FALSE END AS insurance_sign_up_date_parse_error,\n  \n  -- Address components\n  ap.address_raw,\n  ap.address_clean,\n  ap.postal_code,\n  ap.city,\n  ap.street_and_number,\n  \n  -- Standardized gender\n  CASE\n    WHEN UPPER(TRIM(s.gender_raw)) IN ('M', 'MALE') THEN 'male'\n    WHEN UPPER(TRIM(s.gender_raw)) IN ('F', 'FEMALE') THEN 'female'\n    ELSE 'unknown'\n  END AS gender_std,\n  \n  -- Standardized family status\n  CASE\n    WHEN UPPER(TRIM(s.family_status_raw)) = 'SINGLE' THEN 'single'\n    WHEN UPPER(TRIM(s.family_status_raw)) = 'MARRIED' THEN 'married'\n    WHEN UPPER(TRIM(s.family_status_raw)) = 'DIVORCED' THEN 'divorced'\n    WHEN UPPER(TRIM(s.family_status_raw)) = 'WIDOWED' THEN 'widowed'\n    ELSE 'unknown'\n  END AS family_status_std,\n  \n  -- Standardized insurance status\n  CASE\n    WHEN UPPER(TRIM(s.insurance_status_raw)) = 'ACTIVE' THEN 'active'\n    WHEN UPPER(TRIM(s.insurance_status_raw)) = 'INACTIVE' THEN 'inactive'\n    WHEN UPPER(TRIM(s.insurance_status_raw)) = 'PENDING' THEN 'pending'\n    ELSE 'unknown'\n  END AS insurance_status_std,\n  \n  -- Cleaned occupational category\n  CASE \n    WHEN TRIM(s.occupational_category_raw) = '' THEN NULL\n    ELSE TRIM(s.occupational_category_raw)\n  END AS occupational_category_clean,\n  \n  -- Standardized wealth bracket\n  CASE\n    WHEN UPPER(TRIM(s.wealth_bracket_raw)) IN ('LOW', 'LOWER') THEN 'low'\n    WHEN UPPER(TRIM(s.wealth_bracket_raw)) = 'MEDIUM' THEN 'medium'\n    WHEN UPPER(TRIM(s.wealth_bracket_raw)) IN ('UPPER_MIDDLE', 'UPPER MIDDLE', 'UPPERMIDDLE') THEN 'upper_middle'\n    WHEN UPPER(TRIM(s.wealth_bracket_raw)) IN ('HIGH', 'UPPER') THEN 'high'\n    ELSE 'unknown'\n  END AS wealth_bracket_std\n\nFROM source s\nLEFT JOIN birthdate_parsed bd USING (person_id)\nLEFT JOIN signup_date_parsed sd USING (person_id)\nLEFT JOIN address_parsed ap USING (person_id)\n), deduped AS (\n  SELECT * FROM __dbt__cte__int_person_deduped\n)\n\nSELECT\n  person_id,\n  \n  -- Demographic attributes\n  birthdate_parsed AS birthdate,\n  CASE \n    WHEN birthdate_parsed IS NOT NULL \n    THEN DATE_DIFF(CURRENT_DATE(), birthdate_parsed, YEAR)\n    ELSE NULL \n  END AS age_years,\n  gender_std AS gender,\n  family_status_std AS family_status,\n  \n  -- Insurance attributes\n  insurance_status_std AS insurance_status,\n  insurance_sign_up_date_parsed AS insurance_sign_up_date,\n  EXTRACT(YEAR FROM insurance_sign_up_date_parsed) AS signup_year,\n  FORMAT_DATE('%Y-%m', insurance_sign_up_date_parsed) AS signup_month,\n  \n  -- Economic attributes\n  occupational_category_clean AS occupational_category,\n  wealth_bracket_std AS wealth_bracket,\n  \n  -- Address attributes\n  address_clean AS address,\n  street_and_number,\n  postal_code,\n  city,\n  \n  -- Data quality flags\n  birthdate_parse_error,\n  insurance_sign_up_date_parse_error,\n  CURRENT_TIMESTAMP() AS dim_updated_at\n\nFROM deduped", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev_core`.`dim_person`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:50.434848Z", "completed_at": "2026-01-05T14:37:50.441145Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:50.455066Z", "completed_at": "2026-01-05T14:37:51.530574Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 1.1110610961914062, "adapter_response": {"_message": "CREATE VIEW (0 processed)", "code": "CREATE VIEW", "bytes_processed": 0, "bytes_billed": 0, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "7b95cc25-0f6b-4254-b44a-5cba506c1b6d", "slot_ms": 0}, "message": "CREATE VIEW (0 processed)", "failures": null, "unique_id": "model.health_insurance_dbt.parse_error_rate", "compiled": true, "compiled_code": "-- Test: Parse error rate should be below threshold (5%)\n-- This test fails if too many records have parse errors\n\nWITH error_counts AS (\n  SELECT\n    COUNT(*) AS total_records,\n    SUM(CASE WHEN birthdate_parse_error THEN 1 ELSE 0 END) AS birthdate_errors,\n    SUM(CASE WHEN insurance_sign_up_date_parse_error THEN 1 ELSE 0 END) AS signup_date_errors\n  FROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`dim_person`\n),\n\nerror_rates AS (\n  SELECT\n    total_records,\n    birthdate_errors,\n    signup_date_errors,\n    ROUND(100.0 * birthdate_errors / NULLIF(total_records, 0), 2) AS birthdate_error_pct,\n    ROUND(100.0 * signup_date_errors / NULLIF(total_records, 0), 2) AS signup_date_error_pct\n  FROM error_counts\n)\n\n-- Fail if error rate exceeds 5%\nSELECT\n  'birthdate' AS field,\n  birthdate_errors AS error_count,\n  total_records,\n  birthdate_error_pct AS error_rate_pct\nFROM error_rates\nWHERE birthdate_error_pct > 5\n\nUNION ALL\n\nSELECT\n  'insurance_sign_up_date' AS field,\n  signup_date_errors AS error_count,\n  total_records,\n  signup_date_error_pct AS error_rate_pct\nFROM error_rates\nWHERE signup_date_error_pct > 5", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev`.`parse_error_rate`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:50.422138Z", "completed_at": "2026-01-05T14:37:50.440700Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:50.441520Z", "completed_at": "2026-01-05T14:37:53.824263Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 3.405726909637451, "adapter_response": {"_message": "CREATE TABLE (500.0 rows, 12.7 KiB processed)", "code": "CREATE TABLE", "rows_affected": 500, "bytes_processed": 12962, "bytes_billed": 20971520, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "479a2628-c4e2-428b-9610-ff68a270de4d", "slot_ms": 7844}, "message": "CREATE TABLE (500.0 rows, 12.7 KiB processed)", "failures": null, "unique_id": "model.health_insurance_dbt.fact_insurance_yearly", "compiled": true, "compiled_code": "\n\n-- Insurance facts by person and year\n-- Grain: One row per person_id + year\n-- Incremental strategy: Merge on (person_id, year)\n\nWITH facts_raw AS (\n  SELECT * FROM `dw-health-insurance-bipm`.`health_insurance_dev_staging`.`stg_insurance_facts_raw`\n),\n\nperson_dim AS (\n  SELECT person_id FROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`dim_person`\n)\n\nSELECT\n  f.person_id,\n  f.year,\n  \n  -- Metrics\n  f.insurance_cost_year,\n  f.annual_doctor_visits,\n  f.annual_cost_to_insurance,\n  \n  -- Data quality flags\n  f.insurance_cost_year_parse_error,\n  f.annual_doctor_visits_parse_error,\n  f.annual_cost_to_insurance_parse_error,\n  f.year_parse_error,\n  \n  -- Referential integrity check\n  CASE WHEN p.person_id IS NULL THEN TRUE ELSE FALSE END AS orphan_record,\n  \n  -- Metadata\n  CURRENT_TIMESTAMP() AS fact_updated_at\n\nFROM facts_raw f\nLEFT JOIN person_dim p USING (person_id)\n\nWHERE f.year IS NOT NULL\n  AND f.person_id IS NOT NULL\n\n", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev_core`.`fact_insurance_yearly`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:53.846434Z", "completed_at": "2026-01-05T14:37:53.864380Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:53.865595Z", "completed_at": "2026-01-05T14:37:55.047931Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 1.2119040489196777, "adapter_response": {"_message": "CREATE VIEW (0 processed)", "code": "CREATE VIEW", "bytes_processed": 0, "bytes_billed": 0, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "658f4947-1f8b-4073-97ee-31585396a9ca", "slot_ms": 0}, "message": "CREATE VIEW (0 processed)", "failures": null, "unique_id": "model.health_insurance_dbt.negative_costs", "compiled": true, "compiled_code": "-- Test: No negative costs in fact table\n-- This test fails if any negative values exist in cost columns\n\nSELECT\n  person_id,\n  year,\n  insurance_cost_year,\n  annual_cost_to_insurance\nFROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`fact_insurance_yearly`\nWHERE\n  (insurance_cost_year < 0 AND insurance_cost_year IS NOT NULL)\n  OR (annual_cost_to_insurance < 0 AND annual_cost_to_insurance IS NOT NULL)", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev`.`negative_costs`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:55.054306Z", "completed_at": "2026-01-05T14:37:55.059764Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:55.060464Z", "completed_at": "2026-01-05T14:37:56.086755Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 1.0352239608764648, "adapter_response": {"_message": "CREATE VIEW (0 processed)", "code": "CREATE VIEW", "bytes_processed": 0, "bytes_billed": 0, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "77c13e0e-9a90-4b12-8b70-f203cab59cdd", "slot_ms": 0}, "message": "CREATE VIEW (0 processed)", "failures": null, "unique_id": "model.health_insurance_dbt.orphan_records", "compiled": true, "compiled_code": "-- Test: Flag orphan records in fact table (for monitoring)\n-- This test warns if orphan records exist (not a hard failure)\n\nSELECT\n  person_id,\n  year,\n  'Fact record has no matching person in dim_person' AS issue\nFROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`fact_insurance_yearly`\nWHERE orphan_record = TRUE", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev`.`orphan_records`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:53.852644Z", "completed_at": "2026-01-05T14:37:53.864691Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:53.867671Z", "completed_at": "2026-01-05T14:37:56.829254Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 2.99241304397583, "adapter_response": {"_message": "CREATE TABLE (159.0 rows, 34.5 KiB processed)", "code": "CREATE TABLE", "rows_affected": 159, "bytes_processed": 35314, "bytes_billed": 20971520, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "92abe79d-46e7-47e2-8129-fb521fd3aff7", "slot_ms": 9326}, "message": "CREATE TABLE (159.0 rows, 34.5 KiB processed)", "failures": null, "unique_id": "model.health_insurance_dbt.mart_city_year_kpis", "compiled": true, "compiled_code": "\n\n-- City-level yearly aggregations for geographic analysis\n-- Grain: One row per city + year\n-- BI Use: Regional performance, geographic segmentation, market analysis\n\nWITH facts AS (\n  SELECT * FROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`fact_insurance_yearly`\n  WHERE NOT orphan_record\n),\n\nperson_dim AS (\n  SELECT * FROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`dim_person`\n)\n\nSELECT\n  COALESCE(p.city, 'Unknown') AS city,\n  p.postal_code,\n  f.year,\n  \n  -- Volume metrics\n  COUNT(DISTINCT f.person_id) AS persons_in_city,\n  \n  -- Cost aggregates\n  SUM(f.insurance_cost_year) AS total_insurance_cost,\n  SUM(f.annual_cost_to_insurance) AS total_cost_to_insurance,\n  AVG(f.insurance_cost_year) AS avg_insurance_cost_per_person,\n  AVG(f.annual_cost_to_insurance) AS avg_cost_to_insurance_per_person,\n  \n  -- Visit aggregates\n  SUM(f.annual_doctor_visits) AS total_doctor_visits,\n  AVG(f.annual_doctor_visits) AS avg_doctor_visits_per_person,\n  \n  -- Demographics\n  AVG(p.age_years) AS avg_age,\n  COUNTIF(p.gender = 'male') AS male_count,\n  COUNTIF(p.gender = 'female') AS female_count,\n  \n  -- Wealth distribution\n  COUNTIF(p.wealth_bracket = 'low') AS low_wealth_count,\n  COUNTIF(p.wealth_bracket = 'medium') AS medium_wealth_count,\n  COUNTIF(p.wealth_bracket = 'upper_middle') AS upper_middle_wealth_count,\n  COUNTIF(p.wealth_bracket = 'high') AS high_wealth_count,\n  \n  -- Insurance status\n  COUNTIF(p.insurance_status = 'active') AS active_count,\n  COUNTIF(p.insurance_status = 'inactive') AS inactive_count,\n  \n  -- Metadata\n  CURRENT_TIMESTAMP() AS mart_updated_at\n\nFROM person_dim p\nINNER JOIN facts f USING (person_id)\nWHERE p.city IS NOT NULL\nGROUP BY\n  p.city,\n  p.postal_code,\n  f.year", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev_marts`.`mart_city_year_kpis`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:56.093657Z", "completed_at": "2026-01-05T14:37:56.099204Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:56.099752Z", "completed_at": "2026-01-05T14:37:57.005395Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.9135608673095703, "adapter_response": {"_message": "CREATE VIEW (0 processed)", "code": "CREATE VIEW", "bytes_processed": 0, "bytes_billed": 0, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "a1431f8c-a572-4c15-9045-68c4ab70ce35", "slot_ms": 0}, "message": "CREATE VIEW (0 processed)", "failures": null, "unique_id": "model.health_insurance_dbt.visits_reasonable", "compiled": true, "compiled_code": "-- Test: Doctor visits should be between 0 and 365 per year\n-- This test fails if values are outside reasonable bounds\n\nSELECT\n  person_id,\n  year,\n  annual_doctor_visits\nFROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`fact_insurance_yearly`\nWHERE\n  annual_doctor_visits IS NOT NULL\n  AND (annual_doctor_visits < 0 OR annual_doctor_visits > 365)", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev`.`visits_reasonable`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:53.839903Z", "completed_at": "2026-01-05T14:37:53.865036Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:54.094285Z", "completed_at": "2026-01-05T14:37:57.383388Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 3.5483360290527344, "adapter_response": {"_message": "CREATE TABLE (122.0 rows, 34.8 KiB processed)", "code": "CREATE TABLE", "rows_affected": 122, "bytes_processed": 35623, "bytes_billed": 20971520, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "971a542b-260d-4c64-aef1-e6930b8549fc", "slot_ms": 10639}, "message": "CREATE TABLE (122.0 rows, 34.8 KiB processed)", "failures": null, "unique_id": "model.health_insurance_dbt.mart_person_kpis", "compiled": true, "compiled_code": "\n\n-- Person-level KPIs aggregated across all years\n-- Grain: One row per person_id\n-- BI Use: Customer 360 view, lifetime value analysis, customer segmentation\n\nWITH facts AS (\n  SELECT * FROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`fact_insurance_yearly`\n  WHERE NOT orphan_record  -- Exclude orphan records\n),\n\nperson_dim AS (\n  SELECT * FROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`dim_person`\n)\n\nSELECT\n  p.person_id,\n  \n  -- Demographic context\n  p.gender,\n  p.age_years,\n  p.family_status,\n  p.wealth_bracket,\n  p.city,\n  p.insurance_status,\n  \n  -- Temporal coverage\n  MIN(f.year) AS first_data_year,\n  MAX(f.year) AS last_data_year,\n  COUNT(DISTINCT f.year) AS years_with_data,\n  \n  -- Lifetime aggregates\n  SUM(f.insurance_cost_year) AS lifetime_insurance_cost,\n  SUM(f.annual_cost_to_insurance) AS lifetime_cost_to_insurance,\n  SUM(f.annual_doctor_visits) AS lifetime_doctor_visits,\n  \n  -- Averages\n  AVG(f.insurance_cost_year) AS avg_insurance_cost_per_year,\n  AVG(f.annual_cost_to_insurance) AS avg_cost_to_insurance_per_year,\n  AVG(f.annual_doctor_visits) AS avg_doctor_visits_per_year,\n  \n  -- Volatility (stddev)\n  STDDEV(f.annual_cost_to_insurance) AS stddev_cost_to_insurance,\n  STDDEV(f.annual_doctor_visits) AS stddev_doctor_visits,\n  \n  -- Trends (most recent vs earliest year)\n  ARRAY_AGG(\n    f.annual_cost_to_insurance IGNORE NULLS\n    ORDER BY f.year DESC\n    LIMIT 1\n  )[SAFE_OFFSET(0)] AS latest_year_cost,\n  ARRAY_AGG(\n    f.annual_cost_to_insurance IGNORE NULLS\n    ORDER BY f.year ASC\n    LIMIT 1\n  )[SAFE_OFFSET(0)] AS earliest_year_cost,\n-- Metadata\n  CURRENT_TIMESTAMP() AS mart_updated_at\nFROM person_dim p\nLEFT JOIN facts f USING (person_id)\nGROUP BY\np.person_id,\np.gender,\np.age_years,\np.family_status,\np.wealth_bracket,\np.city,\np.insurance_status", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev_marts`.`mart_person_kpis`", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2026-01-05T14:37:53.849436Z", "completed_at": "2026-01-05T14:37:53.865311Z"}, {"name": "execute", "started_at": "2026-01-05T14:37:54.095282Z", "completed_at": "2026-01-05T14:37:57.421840Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 3.585141181945801, "adapter_response": {"_message": "CREATE TABLE (122.0 rows, 34.8 KiB processed)", "code": "CREATE TABLE", "rows_affected": 122, "bytes_processed": 35623, "bytes_billed": 20971520, "location": "EU", "project_id": "dw-health-insurance-bipm", "job_id": "11690b35-77d6-43d4-a82b-8a45d2bed1e8", "slot_ms": 11566}, "message": "CREATE TABLE (122.0 rows, 34.8 KiB processed)", "failures": null, "unique_id": "model.health_insurance_dbt.mart_yearly_kpis", "compiled": true, "compiled_code": "\n\n-- Person-level KPIs aggregated across all years\n-- Grain: One row per person_id\n-- BI Use: Customer 360 view, lifetime value analysis, customer segmentation\n\nWITH facts AS (\n  SELECT * FROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`fact_insurance_yearly`\n  WHERE NOT orphan_record  -- Exclude orphan records\n),\n\nperson_dim AS (\n  SELECT * FROM `dw-health-insurance-bipm`.`health_insurance_dev_core`.`dim_person`\n)\n\nSELECT\n  p.person_id,\n  \n  -- Demographic context\n  p.gender,\n  p.age_years,\n  p.family_status,\n  p.wealth_bracket,\n  p.city,\n  p.insurance_status,\n  \n  -- Temporal coverage\n  MIN(f.year) AS first_data_year,\n  MAX(f.year) AS last_data_year,\n  COUNT(DISTINCT f.year) AS years_with_data,\n  \n  -- Lifetime aggregates\n  SUM(f.insurance_cost_year) AS lifetime_insurance_cost,\n  SUM(f.annual_cost_to_insurance) AS lifetime_cost_to_insurance,\n  SUM(f.annual_doctor_visits) AS lifetime_doctor_visits,\n  \n  -- Averages\n  AVG(f.insurance_cost_year) AS avg_insurance_cost_per_year,\n  AVG(f.annual_cost_to_insurance) AS avg_cost_to_insurance_per_year,\n  AVG(f.annual_doctor_visits) AS avg_doctor_visits_per_year,\n  \n  -- Volatility (stddev)\n  STDDEV(f.annual_cost_to_insurance) AS stddev_cost_to_insurance,\n  STDDEV(f.annual_doctor_visits) AS stddev_doctor_visits,\n  \n  -- Trends (most recent vs earliest year)\n  ARRAY_AGG(\n    f.annual_cost_to_insurance IGNORE NULLS\n    ORDER BY f.year DESC\n    LIMIT 1\n  )[SAFE_OFFSET(0)] AS latest_year_cost,\n  ARRAY_AGG(\n    f.annual_cost_to_insurance IGNORE NULLS\n    ORDER BY f.year ASC\n    LIMIT 1\n  )[SAFE_OFFSET(0)] AS earliest_year_cost,\n  -- Metadata\n  CURRENT_TIMESTAMP() AS mart_updated_at\nFROM person_dim p\nLEFT JOIN facts f USING (person_id)\nGROUP BY\np.person_id,\np.gender,\np.age_years,\np.family_status,\np.wealth_bracket,\np.city,\np.insurance_status", "relation_name": "`dw-health-insurance-bipm`.`health_insurance_dev_marts`.`mart_yearly_kpis`", "batch_results": null}], "elapsed_time": 14.579712867736816, "args": {"send_anonymous_usage_stats": true, "log_format": "default", "require_ref_searches_node_package_before_root": false, "require_yaml_configuration_for_mf_time_spines": false, "require_resource_names_without_spaces": true, "printer_width": 80, "state_modified_compare_more_unrendered_values": false, "introspect": true, "empty": false, "invocation_command": "dbt run --full-refresh", "indirect_selection": "eager", "version_check": true, "state_modified_compare_vars": false, "project_dir": "/Users/nikolasjackaltran/Desktop/HWR/DWH/health_insurance_dbt", "log_file_max_bytes": 10485760, "require_all_warnings_handled_by_warn_error": false, "static_parser": true, "print": true, "profiles_dir": "/Users/nikolasjackaltran/Desktop/HWR/DWH/health_insurance_dbt", "require_nested_cumulative_type_params": false, "quiet": false, "log_format_file": "debug", "exclude": [], "show_resource_report": false, "source_freshness_run_project_hooks": true, "favor_state": false, "macro_debugging": false, "which": "run", "strict_mode": false, "use_fast_test_edges": false, "defer": false, "cache_selected_only": false, "partial_parse": true, "skip_nodes_if_on_run_start_fails": false, "upload_to_artifacts_ingest_api": false, "warn_error_options": {"error": [], "warn": [], "silence": []}, "full_refresh": true, "require_unique_project_resource_names": false, "write_json": true, "require_batched_execution_for_custom_microbatch_strategy": false, "log_level": "info", "require_explicit_package_overrides_for_builtin_materializations": true, "use_colors": true, "use_colors_file": true, "partial_parse_file_diff": true, "log_level_file": "debug", "populate_cache": true, "select": [], "require_generic_test_arguments_property": true, "validate_macro_args": false, "log_path": "/Users/nikolasjackaltran/Desktop/HWR/DWH/health_insurance_dbt/logs", "show_all_deprecations": false, "vars": {}}}